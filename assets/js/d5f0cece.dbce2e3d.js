"use strict";(self.webpackChunk_detekt_website=self.webpackChunk_detekt_website||[]).push([[1820],{38076:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>d,contentTitle:()=>a,default:()=>c,frontMatter:()=>r,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"introduction/suppressors","title":"Suppressors","description":"The Suppressors are a tool that you can use to customize the reports of detekt. They allow you to (surprise) suppress some issues detected by some rules, and they can be applied to any rule.","source":"@site/versioned_docs/version-1.23.1/introduction/suppressors.md","sourceDirName":"introduction","slug":"/introduction/suppressors","permalink":"/docs/1.23.1/introduction/suppressors","draft":false,"unlisted":false,"editUrl":"https://github.com/detekt/detekt/edit/main/website/versioned_docs/version-1.23.1/introduction/suppressors.md","tags":[],"version":"1.23.1","sidebarPosition":8,"frontMatter":{"id":"suppressors","title":"Suppressors","keywords":["suppressing","issues","smells"],"sidebar_position":8},"sidebar":"defaultSidebar","previous":{"title":"Code Smell Baseline","permalink":"/docs/1.23.1/introduction/baseline"},"next":{"title":"Extending detekt","permalink":"/docs/1.23.1/introduction/extensions"}}');var o=n(74848),i=n(28453);const r={id:"suppressors",title:"Suppressors",keywords:["suppressing","issues","smells"],sidebar_position:8},a=void 0,d={},l=[{value:"Available <code>Suppressor</code>s",id:"available-suppressors",level:2},{value:"Annotation Suppressor",id:"annotation-suppressor",level:3},{value:"Config tag",id:"config-tag",level:5},{value:"Function Suppressor",id:"function-suppressor",level:3},{value:"Config tag:",id:"config-tag-1",level:5}];function u(e){const s={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",h5:"h5",p:"p",pre:"pre",strong:"strong",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(s.p,{children:["The ",(0,o.jsx)(s.code,{children:"Suppressor"}),"s are a tool that you can use to customize the reports of detekt. They allow you to (surprise) suppress some issues detected by some rules, and they can be applied to any rule."]}),"\n",(0,o.jsxs)(s.p,{children:["An example is the ",(0,o.jsx)(s.strong,{children:"annotation"})," suppressor. It works like this. First, you need to configure the tag ",(0,o.jsx)(s.code,{children:"ignoreAnnotated"})," with a list of annotations, you want the suppressor to consider. Example:"]}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{className:"language-yaml",children:"UnusedPrivateMember:\n  active: true\n  ignoreAnnotated:\n    - 'Preview'\n"})}),"\n",(0,o.jsxs)(s.p,{children:["Now, if an issue is found under a code that is annotated with ",(0,o.jsx)(s.code,{children:"@Preview"})," that issue will be suppressed. This example is really handy if you use ",(0,o.jsx)(s.a,{href:"/docs/introduction/compose",children:"Jetpack Compose"}),", for example."]}),"\n",(0,o.jsxs)(s.h2,{id:"available-suppressors",children:["Available ",(0,o.jsx)(s.code,{children:"Suppressor"}),"s"]}),"\n",(0,o.jsx)(s.h3,{id:"annotation-suppressor",children:"Annotation Suppressor"}),"\n",(0,o.jsxs)(s.p,{children:["Suppress all the issues that are raised under a code that is annotated with the annotations defined at ",(0,o.jsx)(s.code,{children:"ignoreAnnotated"}),"."]}),"\n",(0,o.jsx)(s.h5,{id:"config-tag",children:"Config tag"}),"\n",(0,o.jsxs)(s.p,{children:[(0,o.jsx)(s.code,{children:"ignoreAnnotated: List<String>"}),": The annotations can be defined just by its name or with its fully qualified name. If you don't run detekt with type solving the fully qualified name does not work."]}),"\n",(0,o.jsx)(s.h3,{id:"function-suppressor",children:"Function Suppressor"}),"\n",(0,o.jsxs)(s.p,{children:["Suppress any issue raised under a function definition that matches the signatures defined at ",(0,o.jsx)(s.code,{children:"ignoreFunction"}),"."]}),"\n",(0,o.jsxs)(s.p,{children:[(0,o.jsx)(s.em,{children:"Note"}),": this Suppressor doesn't suppress issues found when you call these functions. It just suppresses the ones in the function ",(0,o.jsx)(s.strong,{children:"definition"}),"."]}),"\n",(0,o.jsx)(s.h5,{id:"config-tag-1",children:"Config tag:"}),"\n",(0,o.jsxs)(s.p,{children:[(0,o.jsx)(s.code,{children:"ignoreFunction: List<String>"}),": The signature of the function. You can ignore all the overloads of a function defining just its name like ",(0,o.jsx)(s.code,{children:"java.time.LocalDate.now"})," or you can specify the parameters to only suppress one: ",(0,o.jsx)(s.code,{children:"java.time.LocalDate(java.time.Clock)"}),"."]}),"\n",(0,o.jsxs)(s.p,{children:[(0,o.jsx)(s.em,{children:"Note:"})," you need to write all the types with fully qualified names e.g. ",(0,o.jsx)(s.code,{children:"org.example.foo(kotlin.String)"}),". It is important to add ",(0,o.jsx)(s.code,{children:"kotlin.String"}),". Just adding ",(0,o.jsx)(s.code,{children:"String"})," will not work."]})]})}function c(e={}){const{wrapper:s}={...(0,i.R)(),...e.components};return s?(0,o.jsx)(s,{...e,children:(0,o.jsx)(u,{...e})}):u(e)}},28453:(e,s,n)=>{n.d(s,{R:()=>r,x:()=>a});var t=n(96540);const o={},i=t.createContext(o);function r(e){const s=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function a(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),t.createElement(i.Provider,{value:s},e.children)}}}]);